# Proposal 004: Currying and Partial Application

**Status**: Proposed  
**Author**: MiniML Team  
**Date**: 2026-02-06

## Problem

Multi-parameter functions in MiniML are compiled as methods that take all arguments at once, but when passed as values (first-class functions), we can only wrap single-parameter functions in Java's `Function` interface.

This fails:
```ocaml
fn fold_left (f: 'acc -> 'elem -> 'acc) (init: 'acc) (lst: list<'elem>): 'acc = ...

let folder = fold_left in  # Can't wrap a 3-parameter function as Function
folder add_func 0 [1, 2, 3]
```

Error: `Multi-arg function application via Function interface not yet supported`

Additionally, MiniML functions are defined with multiple parameters but should support partial application (applying fewer arguments than the function expects), which is fundamental to functional programming.

## Solution

Implement **automatic currying** for multi-parameter functions, transforming them into chains of single-parameter functions that return functions. This aligns with ML family semantics and enables:
1. Functions as values (already partially working for single-parameter functions)
2. Partial application (applying subset of arguments)
3. Function composition
4. Higher-order programming patterns

### Key Insight

In ML languages, `fn f a b c = body` is syntactic sugar for `fn f = fun a -> fun b -> fun c -> body`. Every function is actually a single-parameter function that returns another function.

## User-Facing Syntax

No syntax changes needed. Current syntax already implies currying:

```ocaml
# Multi-parameter function definition
fn add (x: int) (y: int): int = x + y

# These should all work:
add 3 5              # Full application → 8
let add3 = add 3 in  # Partial application → function
add3 5               # Apply remaining arg → 8

# Passing to higher-order functions
map (add 1) [1, 2, 3]  # Partial application as argument → [2, 3, 4]
```

## Semantics

### Function Types

Multi-parameter function types are right-associative:
```ocaml
'a -> 'b -> 'c   ≡   'a -> ('b -> 'c)
```

A function taking two arguments and returning a result:
```ocaml
fn add (x: int) (y: int): int = x + y
# Type: int -> (int -> int)
```

### Partial Application

Applying fewer arguments than defined returns a function:
```ocaml
fn greet (greeting: string) (name: string): string = 
  greeting ++ " " ++ name

let say_hello = greet "Hello" in  # Type: string -> string
say_hello "Alice"                  # → "Hello Alice"
```

### Full Application

Applying all arguments evaluates the body:
```ocaml
add 3 5  # → 8
```

## Detailed Design

### Current Implementation (Single-Parameter Functions)

Already working for `fn f (x: 'a): 'b`:
1. Generate static method `lambda_f(Object)Object`
2. Wrap in Function object via `invokedynamic` when used as value
3. Call via `Function.apply()` when parameter is Function type

### Proposed Implementation (Multi-Parameter Functions)

#### Strategy 1: Nested Function Objects (F# approach)

Transform multi-parameter functions into nested Function objects:

**Source:**
```ocaml
fn add (x: int) (y: int): int = x + y
```

**Generated (conceptual Java):**
```java
// Return a Function that captures nothing and returns a Function
static Function<Integer, Function<Integer, Integer>> lambda_add() {
    return x -> y -> x + y;
}
```

**Challenges:**
- Requires capturing environment for each closure level
- Multiple levels of boxing/unboxing
- Type: `Function<A, Function<B, C>>` gets complex quickly

#### Strategy 2: Static Method with Arity Tracking (Recommended)

Keep static methods for full application, generate partial application wrappers on demand:

**Source:**
```ocaml
fn add (x: int) (y: int): int = x + y
```

**Generated bytecode:**
```java
// Full application - static method (fast path)
static int lambda_add(int x, int y) {
    return x + y;
}

// When used as value - generate wrapper that captures first arg
// This happens at the call site, not definition site
static Function<Integer, Function<Integer, Integer>> lambda_add$wrapper() {
    return x -> y -> lambda_add(x, y);
}
```

**At call sites:**
```ocaml
add 3 5              # → invokestatic lambda_add(II)I
let add3 = add 3 in  # → Generate closure capturing 3
add3 5               # → invoke captured closure with 5
```

### Implementation Steps

#### 1. Detect Partial Application at Call Sites

In `compileApp()`, check if fewer arguments than function arity:
```java
Type funcType = letRecTypes.get(funcName);
int expectedArity = countParams(funcType);  // Count TFun nesting
int providedArity = args.size();

if (providedArity < expectedArity) {
    // Generate partial application closure
    generatePartialClosure(funcName, funcType, args);
} else {
    // Normal full application
    compileFullApp(funcName, args);
}
```

#### 2. Generate Partial Application Closure

Create a nested class or lambda that captures the provided arguments:
```java
private void generatePartialClosure(String funcName, Type funcType, List<Expr> providedArgs) {
    // Generate invokedynamic that captures providedArgs and returns Function
    // The returned Function will take remaining args and call the full method
    
    // Example for add 3:
    // BIPUSH 3  (provided arg)
    // INVOKEDYNAMIC makeClosure (I)Function  // Capture int, return Function
    // Bootstrap method creates: y -> lambda_add(3, y)
}
```

#### 3. Function Reference Without Application

When function is referenced without any arguments:
```java
case Var(String name) when letRecTypes.containsKey(name) -> {
    // Already implemented - wrap as Function
    // But needs to handle multi-parameter case
    Type funcType = letRecTypes.get(name);
    int arity = countParams(funcType);
    if (arity == 1) {
        wrapFunctionAsObject(name, funcType);  // Current implementation
    } else {
        wrapMultiParamFunction(name, funcType);  // NEW
    }
}
```

### Type Erasure Interaction

Curried functions with type variables still use type erasure:
```ocaml
fn map (f: 'a -> 'b) (lst: list<'a>): list<'b> = ...
```

Compiles to:
```java
static List lambda_map(Function f, List lst) { ... }

// When partially applied: map f
Function<List, List> lambda_map$partial1(Function f) {
    return lst -> lambda_map(f, lst);
}
```

## Benefits

### 1. First-Class Multi-Parameter Functions

Can pass any function as a value:
```ocaml
fn fold_left (f: 'acc -> 'elem -> 'acc) (init: 'acc) (lst: list<'elem>): 'acc = ...

let folder = fold_left add_func 0 in  # Partial application
folder [1, 2, 3]  # → 6
```

### 2. Enables Standard Library

Can implement classic higher-order functions:
```ocaml
fn compose (f: 'b -> 'c) (g: 'a -> 'b) (x: 'a): 'c = f (g x)

let double_then_show = compose show double in
double_then_show 21  # → "42"
```

### 3. Point-Free Style

Write code without explicitly naming arguments:
```ocaml
let increment_all = map (add 1) in
increment_all [1, 2, 3]  # → [2, 3, 4]
```

### 4. Better Modularity

Partial application enables creating specialized functions:
```ocaml
fn fetch_with_timeout (timeout: int) (url: string): result<string, string> = ...

let quick_fetch = fetch_with_timeout 100 in
quick_fetch "http://api.example.com"
```

## Drawbacks

### 1. Performance Overhead

Each partial application creates a closure object:
```ocaml
add 3 5  # Fast: direct method call
let add3 = add 3 in add3 5  # Slower: creates closure, captures arg
```

**Mitigation**: JVM JIT can inline small closures. Only pay cost when partial application is used.

### 2. Complexity

Currying implementation adds significant complexity to the compiler:
- Track function arity
- Generate partial application closures dynamically
- Handle captured variable scopes

**Mitigation**: Implement incrementally, test thoroughly.

### 3. Debugging

Stack traces become less clear with nested closures:
```
at lambda_add$partial1.apply(Unknown Source)
at lambda_map.lambda$0(Unknown Source)
```

**Mitigation**: Generate descriptive method names, maintain source location info.

### 4. Interaction with Java Interop

Java methods aren't curried. Calling multi-parameter Java methods won't support partial application:
```ocaml
java_call "java.lang.Math" "max" 3 5  # OK - full application
let max3 = java_call "java.lang.Math" "max" 3 in  # Won't work
```

**Mitigation**: Document limitation. Java interop requires full application.

## Alternatives Considered

### Alternative 1: Explicit Currying Syntax

Require special syntax for curried functions:
```ocaml
fn add (x: int) -> (y: int) -> int = x + y  # Explicitly curried
fn add (x: int) (y: int): int = x + y       # Not curried (takes tuple)
```

**Rejected**: Diverges from ML family conventions. MiniML already uses ML syntax where all functions are conceptually curried.

### Alternative 2: No Currying, Require Explicit Lambdas

Force users to write nested lambdas manually:
```ocaml
fn add x = fun y -> x + y  # Manual currying
```

**Rejected**: Verbose, defeats purpose of ML-style syntax. Users already write `fn add x y = ...` and expect it to work as curried.

### Alternative 3: Special Operators for Partial Application

Introduce operator for partial application:
```ocaml
let add3 = add <| 3  # Special operator
```

**Rejected**: Unnecessary syntax complexity. Automatic currying is more elegant and matches ML semantics.

## Test Plan

### Test 1: Basic Partial Application
```ocaml
# Expected: 8
fn add (x: int) (y: int): int = x + y in
let add3 = add 3 in
add3 5
```

### Test 2: Multi-Level Partial Application
```ocaml
# Expected: 42
fn triple (x: int) (y: int) (z: int): int = x + y + z in
let add10 = triple 10 in
let add30 = add10 20 in
add30 12
```

### Test 3: Higher-Order with Partial Application
```ocaml
# Expected: [2, 3, 4]
fn map (f: 'a -> 'b) (lst: list<'a>): list<'b> = ... in
fn add (x: int) (y: int): int = x + y in
map (add 1) [1, 2, 3]
```

### Test 4: Function Composition
```ocaml
# Expected: "42"
fn compose (f: 'b -> 'c) (g: 'a -> 'b) (x: 'a): 'c = f (g x) in
fn double (x: int): int = x * 2 in
fn show (x: int): string = java_call "Integer" "toString" x in
compose show double 21
```

## Implementation Checklist

- [ ] Add arity tracking for function types
- [ ] Detect partial application in `compileApp()`
- [ ] Implement `generatePartialClosure()` for 2-parameter functions
- [ ] Extend to N-parameter functions
- [ ] Update `wrapFunctionAsObject()` to handle multi-param functions
- [ ] Test with basic partial application
- [ ] Test with stdlib functions (map, filter)
- [ ] Test with nested partial application
- [ ] Update CLAUDE.md documentation
- [ ] Run full test suite

## Future Work

### Operator Sections

Support partial application of operators:
```ocaml
let increment = (+) 1  # Partially apply + operator
map increment [1, 2, 3]
```

### Pipeline Operator

With currying, pipeline operators become natural:
```ocaml
[1, 2, 3]
  |> map (add 1)
  |> filter (fun x -> x > 2)
  |> fold_left add 0
```

## References

- OCaml Manual - Functions: https://v2.ocaml.org/manual/coreexamples.html#s%3Atut-recvariants
- Haskell Wiki - Currying: https://wiki.haskell.org/Currying
- F# Currying: https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/functions/
- Real World OCaml - First-Class Functions: https://dev.realworldocaml.org/first-class-functions.html
