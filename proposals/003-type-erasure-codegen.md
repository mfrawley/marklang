# Proposal 003: Type Erasure for Polymorphic Code Generation

**Status**: Implemented  
**Author**: MiniML Team  
**Date**: 2026-02-04  
**Implemented**: 2026-02-06

## Problem

Polymorphic type syntax (Proposal 002) is implemented at the lexer, parser, and type inference levels, but code generation fails with "Unresolved type variable" errors. Functions with type variables like `fn identity (x: 'a): 'a = x` cannot compile to JVM bytecode.

Example that fails:
```ocaml
fn identity (x: 'a): 'a = x in
identity 42
```

Error: `Unresolved type variable 't1' during code generation`

## Solution

Use **type erasure** to compile polymorphic functions. Type variables are erased to `Object` at the JVM bytecode level, with casts inserted where needed. This mirrors how Java generics work on the JVM and is the standard approach for functional languages targeting the JVM (Scala, Kotlin, Clojure).

### Why Type Erasure?

We chose type erasure over monomorphization (generating specialized copies for each instantiation) because:

1. **Simplicity**: Single-pass compilation - no need to track all call sites before generating code
2. **Predictable code size**: One function = one compiled method, regardless of how many different types it's used with
3. **Easier separate compilation**: Can compile modules independently without knowing all future uses
4. **Standard JVM approach**: Matches Java generics, proven and well-understood
5. **Sufficient performance**: Boxing overhead is minimal for most use cases (polymorphic functions typically work with heap-allocated compound types like lists, not tight loops over primitives)

Monomorphization would give better performance for primitive-heavy code but requires:
- Two-pass whole-module compilation
- Tracking all instantiations across the entire program
- Complex name mangling and call-site routing
- Code size explosion (100 uses = 100 copies)

For a teaching/experimental language, simplicity wins. We can add monomorphization as an optimization later if needed.

### Key Insight

Type inference ensures type safety at **compile time**. At **runtime**, we only need to handle values correctly - the JVM doesn't need to know about our type variables. We can safely use `Object` and cast as needed.

## Detailed Design

### Example Transformation

**Source:**
```ocaml
fn identity (x: 'a): 'a = x in
let n = identity 42 in
let s = identity "test" in
n + s.length
```

**After type inference:**
- `identity`: `'a -> 'a`
- `identity 42`: instantiate `'a` with `Int`, result type `Int`
- `identity "test"`: instantiate `'a` with `String`, result type `String`

**Generated bytecode (conceptual Java):**
```java
// Single method, uses Object
static Object lambda_identity(Object x) {
    return x;  // Just return, no cast needed here
}

// At call sites, cast based on inferred type
int n = (Integer) lambda_identity(42);        // Cast to Integer
String s = (String) lambda_identity("test");  // Cast to String
int result = n + s.length();
```

### Implementation Strategy

#### 1. Update `Type.toJvmType()`

When encountering type variables during code generation, map them to `Object`:

```java
// In Type.java
public String toJvmType() {
    return switch (this) {
        case TInt() -> "I";
        case TDouble() -> "D";
        case TString() -> "Ljava/lang/String;";
        case TBool() -> "Z";
        case TUnit() -> "Lcom/miniml/Unit;";
        case TList(Type elem) -> "Ljava/util/List;";
        case TFun(Type param, Type ret) -> "Ljava/util/function/Function;";
        case TVar(String name) -> "Ljava/lang/Object;";  // NEW: Erase to Object
        // ... other cases
    };
}
```

#### 2. Track Actual Types Through Compilation

Keep the inferred type information from `TypeInference.typeMap` available during compilation:

```java
// In Compiler.java
private Map<Expr, Type> typeMap;  // From type inference

private void compileExpr(Expr expr) {
    Type inferredType = typeMap.get(expr);  // Look up inferred type
    // ... generate code based on expr
}
```

#### 3. Insert Casts When Needed

After calling a polymorphic function, cast the result to the inferred type:

```java
private void compileApp(App app) {
    Type resultType = typeMap.get(app);  // Get inferred result type
    
    // Compile function and arguments
    compileExpr(app.func());
    for (Expr arg : app.args()) {
        compileExpr(arg);
    }
    
    // Call the function (returns Object if polymorphic)
    mv.visitMethodInsn(INVOKESTATIC, className, methodName, descriptor, false);
    
    // Cast result if polymorphic function returned Object
    Type funcType = typeMap.get(app.func());
    if (isPoly morphic(funcType)) {
        insertCastIfNeeded(resultType);
    }
}

private void insertCastIfNeeded(Type targetType) {
    switch (targetType) {
        case TInt() -> {
            // Object → Integer → int
            mv.visitTypeInsn(CHECKCAST, "java/lang/Integer");
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Integer", "intValue", "()I", false);
        }
        case TDouble() -> {
            // Object → Double → double
            mv.visitTypeInsn(CHECKCAST, "java/lang/Double");
            mv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/Double", "doubleValue", "()D", false);
        }
        case TString() -> {
            // Object → String
            mv.visitTypeInsn(CHECKCAST, "java/lang/String");
        }
        // ... other types
    }
}
```

#### 4. Box Primitive Arguments

When passing primitives to polymorphic functions, box them:

```java
private void compileArg(Expr arg, Type paramType) {
    Type argType = typeMap.get(arg);
    compileExpr(arg);
    
    if (isTypeVar(paramType)) {
        // Parameter is polymorphic, need to box if primitive
        boxIfPrimitive(argType);
    }
}

private void boxIfPrimitive(Type type) {
    switch (type) {
        case TInt() -> {
            // int → Integer
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Integer", "valueOf", 
                             "(I)Ljava/lang/Integer;", false);
        }
        case TDouble() -> {
            // double → Double
            mv.visitMethodInsn(INVOKESTATIC, "java/lang/Double", "valueOf", 
                             "(D)Ljava/lang/Double;", false);
        }
        // ... other primitives
    }
}
```

### Complete Example

**Input:**
```ocaml
fn identity (x: 'a): 'a = x in
identity 42
```

**Generated bytecode:**
```
// Method signature uses Object
static Ljava/lang/Object; lambda_identity(Ljava/lang/Object;)

// Method body
ALOAD 0          // Load parameter (Object)
ARETURN          // Return it (Object)

// Call site
BIPUSH 42        // Push int 42
INVOKESTATIC Integer.valueOf(I)LInteger;  // Box: int → Integer
INVOKESTATIC lambda_identity(LObject;)LObject;  // Call
CHECKCAST Integer                          // Cast: Object → Integer
INVOKEVIRTUAL Integer.intValue()I          // Unbox: Integer → int
```

## Benefits

### 1. Works with JVM Type System

Type erasure is how Java generics work. This approach is proven and well-understood.

### 2. Single Method Per Function

One compiled method handles all types:
- Smaller bytecode
- Simpler compilation
- Easier debugging

### 3. Interop with Java Generics

MiniML generics map naturally to Java generics:
```ocaml
fn map (f: 'a -> 'b) (lst: list<'a>): list<'b>
```
↓
```java
static List<Object> map(Function<Object, Object> f, List<Object> lst)
```

### 4. No Instantiation Tracking

Don't need to track all concrete types a function is used with - just generate one version.

### 5. Enables stdlib

With this, we can compile `stdlib/List.mml`:
```ocaml
fn map (f: 'a -> 'b) (lst: list<'a>): list<'b> = ...
fn filter (pred: 'a -> bool) (lst: list<'a>): list<'a> = ...
```

## Drawbacks

### 1. Boxing Overhead

Primitives must be boxed/unboxed:
- `int` → `Integer` → `Object` → `Integer` → `int`
- Performance cost for tight loops with primitives
- GC pressure from allocations

**Mitigation**: Rare in practice. Most polymorphic functions work with compound types (lists, results, etc.) which are already heap-allocated.

### 2. Runtime Casts

Every use of a polymorphic function result requires a cast. If type inference is wrong, we get `ClassCastException` at runtime instead of compile error.

**Mitigation**: Our type inference is sound. Runtime casts should never fail if type checking passed.

### 3. Primitive Specialization Lost

Can't optimize for specific primitive types. A function working on `int list` has same performance as `Object list`.

**Mitigation**: For performance-critical code, users can write specialized versions manually.

### 4. Method Signature Limitations

Polymorphic methods have less precise signatures when viewed from Java:
```java
// Less useful from Java code
static Object identity(Object x)

// vs specialized versions
static int identity_int(int x)
static String identity_String(String x)
```

**Mitigation**: MiniML code is type-safe internally. Java interop is secondary.

## Alternatives Considered

### Alternative 1: Monomorphization (Rust/C++/MLton style)

Generate specialized code for each concrete instantiation using whole-module compilation:

**Approach:**
```ocaml
fn map f lst =
  match lst with
  | [] -> []
  | hd :: tl -> f hd :: map f tl
  in
map twice [1, 2, 3]
```

**Two-pass compilation:**
1. **Pass 1**: Infer types, collect all instantiations
   - `map` has type `('a -> 'b) -> list<'a> -> list<'b>`
   - Called with `(int -> int) -> list<int> -> list<int>`
2. **Pass 2**: Generate specialized version
   ```java
   private static List<Integer> lambda_map$int$int(
       Function<Integer, Integer> f, 
       List<Integer> lst
   ) {
       // ... body with concrete types ...
   }
   ```

**Pros:**
- No boxing/unboxing overhead - primitives stay unboxed
- Precise types, better Java interop
- JIT can optimize each specialization independently
- Better performance for tight loops with primitives
- Follows proven design from Rust, C++, MLton

**Cons:**
- Code size explosion with many instantiations (e.g., `map` used 20 different ways = 20 copies)
- Must track all uses across entire program before code generation
- Separate compilation becomes hard (need to know all instantiations upfront)
- More complex compiler architecture (requires two-pass compilation)
- Recursive polymorphic functions need careful handling
- Debugging shows mangled names like `map$int$int` in stack traces
- Instantiation limit problem: what if function used with 100 types?

**Implementation Requirements:**
- Deferred compilation architecture (don't compile functions until all call sites analyzed)
- Instantiation collector to track concrete types at call sites
- Name mangling scheme for specialized functions
- Consistent type substitution through recursive calls

**Decision**: Use erasure for initial implementation. Monomorphization could be added as an optimization later for hot paths, possibly as a hybrid approach where we generate both erased and specialized versions.

### Alternative 2: Hybrid Approach

Erase to Object by default, but monomorphize for specific cases (primitives only):
```java
static Object identity_generic(Object x) { ... }  // Default
static int identity_int(int x) { ... }            // Specialized
```

**Decision**: Too complex for initial implementation. Start with pure erasure.

### Alternative 3: Reified Generics (like .NET)

Store type information at runtime and use reflection.

**Decision**: JVM doesn't support reified generics natively. Would require custom runtime support. Too heavyweight.

## Test Plan

### Test 1: Polymorphic Identity (`tests/poly_identity.mml`)
```ocaml
# Expected: true
fn identity (x: 'a): 'a = x in
let n = identity 42 in
let s = identity "test" in
n == 42 && s == "test"
```

Should compile and run successfully.

### Test 2: List Map (`tests/list_map.mml`)
```ocaml
# Expected: [2, 4, 6]
fn map (f: 'a -> 'b) (lst: list<'a>): list<'b> =
  match lst with
  | [] -> []
  | hd :: tl -> f hd :: map f tl
  in

fn twice (x: int): int = x * 2 in
map twice [1, 2, 3]
```

Should compile and run successfully.

### Test 3: Higher-Order Functions (`tests/compose.mml`)
```ocaml
# Expected: 42
fn compose (f: 'b -> 'c) (g: 'a -> 'b) (x: 'a): 'c =
  f (g x) in

fn double (n: int): int = n * 2 in
fn add_one (n: int): int = n + 1 in

compose double add_one 20
```

### Test 4: stdlib/List.mml

All functions should compile:
```ocaml
fn map (f: 'a -> 'b) (lst: list<'a>): list<'b> = ...
fn filter (pred: 'a -> bool) (lst: list<'a>): list<'a> = ...
fn fold_left (f: 'acc -> 'elem -> 'acc) (init: 'acc) (lst: list<'elem>): 'acc = ...
```

## Implementation Checklist

- [ ] Update `Type.TVar.toJvmType()` to return `"Ljava/lang/Object;"`
- [ ] Pass `typeMap` from TypeInference to Compiler
- [ ] Implement `boxIfPrimitive()` helper
- [ ] Implement `insertCastIfNeeded()` helper
- [ ] Update `compileApp()` to insert casts after polymorphic calls
- [ ] Update function parameter compilation to box arguments
- [ ] Test with `tests/poly_identity.mml`
- [ ] Test with `tests/list_map.mml`
- [ ] Test with `stdlib/List.mml`
- [ ] Update CLAUDE.md with type erasure documentation
- [ ] Run full test suite

## Future Optimizations

### Phase 2: Primitive Specialization

Generate specialized versions for common primitives automatically:
```java
// Compiler generates both
static Object identity_generic(Object x)
static int identity_specialized_int(int x)  // No boxing!
```

Route calls based on inferred type.

### Phase 3: Inline Polymorphic Functions

For small polymorphic functions, inline at call sites to eliminate boxing overhead entirely.

### Phase 4: Escape Analysis

Detect when boxed values don't escape and keep them on stack as primitives.

## References

- Java Generics Type Erasure: https://docs.oracle.com/javase/tutorial/java/generics/erasure.html
- Scala's Type Erasure: https://docs.scala-lang.org/tour/generic-classes.html
- MLton (monomorphization): http://mlton.org/Monomorphise
- OCaml's Runtime Representation: https://dev.realworldocaml.org/runtime-memory-layout.html
