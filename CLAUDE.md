# MiniML Compiler - Development Guide

This document provides context for AI assistants working on the MiniML compiler project.

## Project Overview

MiniML is a statically-typed ML-family language that compiles to JVM bytecode. It features:
- Hindley-Milner type inference
- Pattern matching
- Algebraic data types (lists, Result type)
- First-class functions
- Module system

## Key Documentation

- **[GRAMMAR.md](GRAMMAR.md)** - Formal EBNF grammar specification
- **[DESIGN.md](DESIGN.md)** - Architecture and design decisions
- **[BYTECODE.md](BYTECODE.md)** - JVM bytecode generation details

## Build & Test

### Compile
```bash
mvn clean compile
```

### Run Tests
```bash
./run_tests.sh
```

Test files are in `tests/*.mml`. Tests either:
1. Contain `# Expected: <value>` comments, or
2. Default to expecting `true` output

### Compile a Single File
```bash
java -cp "target/classes:$HOME/.m2/repository/org/ow2/asm/asm/9.6/asm-9.6.jar:$HOME/.m2/repository/org/ow2/asm/asm-util/9.6/asm-util-9.6.jar" com.miniml.Main <file.mml>
```

### Run Compiled Class
```bash
java -cp "target/classes:target" <ClassName>
```

## Architecture

### Compilation Pipeline

```
Source (.mml) 
  → Lexer (Lexer.java)
  → Parser (Parser.java) 
  → AST (expr/* package, Module.java, Pattern.java)
  → Type Inference (TypeInference.java)
  → Bytecode Generation (Compiler.java)
  → JVM Class (.class)
```

### Key Components

- **Lexer.java**: Tokenization with position tracking (line:column)
- **Parser.java**: Recursive descent parser producing AST
- **TypeInference.java**: Hindley-Milner type inference with unification
- **Compiler.java**: ASM-based bytecode generation
- **Type.java**: Type system representation
- **expr/* package**: Expression AST nodes (distributed package structure)
  - Each expression type is a separate class implementing `Expr` interface
  - Each has an `eval(Environment env)` method for interpretation
  - Import with: `import com.miniml.expr.*;`
- **Pattern.java**: Pattern matching AST nodes
- **Module.java**: Module-level declarations
- **Environment.java**: Runtime environment for expression evaluation

### Type System

MiniML uses Hindley-Milner type inference:
- **Primitives**: `int`, `double`, `string`, `bool`, `unit`
- **Collections**: `list<'a>`
- **Algebraic**: `result<'a, 'e>` (OCaml-style error handling)
- **Functions**: `'a -> 'b`

Type variables are unified during inference. The compiler maintains a `typeMap` from expressions to inferred types.

### Runtime Classes

Located in `src/main/java/com/miniml/`:
- **Unit.java**: Singleton for unit value `()`
- **Result.java**: Sealed interface with `Ok<T,E>` and `Error<T,E>` records

## Common Tasks

### Adding a New Operator

1. Add token type to `Token.Type` enum
2. Add lexing logic in `Lexer.nextToken()`
3. Add to `Expr.Op` enum
4. Update parser precedence (add new method or extend existing)
5. Add type inference rule in `TypeInference.infer()`
6. Add bytecode generation in `Compiler.compileExpr()`

### Adding a New Expression Type

1. Create a new class in `src/main/java/com/miniml/expr/` implementing `Expr` interface
2. Add an `eval(Environment env)` method for interpretation
3. Add parsing in `Parser.java` (import from `com.miniml.expr.*`)
4. Add type inference in `TypeInference.java` (pattern match on the new type)
5. Add compilation in `Compiler.java` (pattern match on the new type)
6. Add tests in `tests/`

Example:
```java
package com.miniml.expr;
import com.miniml.Environment;

public record NewExpr(/* fields */) implements Expr {
    @Override
    public Object eval(Environment env) {
        // Implementation
    }
}
```

### Pattern Matching

Pattern matching compiles to:
1. Store scrutinee in local variable
2. For each case:
   - Save locals/localTypes state
   - Test pattern (instanceof checks, comparisons)
   - Jump to next case on failure
   - Bind variables, compile body
   - Jump to end
   - Restore locals/localTypes state
3. End label

**Important**: Pattern variables are stored as `Object` in `localTypes` when extracted from algebraic types (Result, etc.). They must be unboxed when used in operations.

## Known Limitations

1. **Function definitions**: Only `fn name params = body in expr` syntax supported. Top-level `let name params = body` is not supported (requires `fn`).
2. **Type annotations**: Not yet supported in surface syntax.
3. **Polymorphism**: Limited support for polymorphic recursion.
4. **Pattern matching**: Nested patterns not fully supported for Result types.

## Error Reporting

Error messages follow the format: `filename:line:column: message`

Example: `tests/bool_and.mml:2:6: Unexpected character '&'`

## Testing Strategy

- Test files in `tests/*.mml`
- Each test should be focused on a single feature
- Use `# Expected:` comments for non-boolean tests
- Boolean tests default to expecting `true`
- Run full test suite with `./run_tests.sh`

## Debugging Tips

### View Generated Bytecode
```bash
javap -c -p <ClassName>
```

### Enable ASM Verification
The compiler uses `ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS` for automatic stack frame computation.

### Common Issues

1. **VerifyError**: Usually stack frame inconsistency. Check that all match branches have consistent local variable states.
2. **Type mismatches**: Check `typeMap` has correct types. Pattern-bound variables from Result are stored as `Object`.
3. **Unboxing**: Variables stored as `Object` need explicit unboxing (CHECKCAST + intValue/doubleValue) before use in operations.

## Planned Features / TODO

Currently no major pending tasks. The expr/ package migration is complete:
- ✅ All 126 Maven tests passing
- ✅ All 52 integration tests passing

Future work ideas:
- Lambda syntax (e.g., `\x y -> x + y`) - Lambda class exists but no surface syntax yet
- Better polymorphic recursion support
- Nested pattern matching for Result types
- REPL improvements

## Contributing

When making changes:
1. Update GRAMMAR.md if syntax changes
2. Add tests for new features
3. Ensure all tests pass: `./run_tests.sh` and `mvn test`
4. Compile stdlib modules if needed: `java -cp ... com.miniml.Main stdlib/Math.mml`
5. Update this document if architecture changes
