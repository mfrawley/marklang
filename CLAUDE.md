# MiniML Compiler - Development Guide

This document provides context for AI assistants working on the MiniML compiler project.

## Project Overview

MiniML is a statically-typed ML-family language that compiles to JVM bytecode. It features:
- Hindley-Milner type inference
- Pattern matching
- Algebraic data types (lists, Result type)
- First-class functions
- Module system

## Key Documentation

- **[GRAMMAR.md](GRAMMAR.md)** - Formal EBNF grammar specification
- **[DESIGN.md](DESIGN.md)** - Architecture and design decisions
- **[BYTECODE.md](BYTECODE.md)** - JVM bytecode generation details

## Build & Test

### Compile
```bash
mvn clean compile
```

### Run Tests
```bash
./run_tests.sh
```

Test files are in `tests/*.ml`. Tests either:
1. Contain `# Expected: <value>` comments, or
2. Default to expecting `true` output

### Compile a Single File
```bash
java -cp "target/classes:$HOME/.m2/repository/org/ow2/asm/asm/9.6/asm-9.6.jar:$HOME/.m2/repository/org/ow2/asm/asm-util/9.6/asm-util-9.6.jar" com.miniml.Main <file.ml>
```

### Run Compiled Class
```bash
java -cp "target/classes:target" <ClassName>
```

## Architecture

### Compilation Pipeline

```
Source (.ml) 
  → Lexer (Lexer.java)
  → Parser (Parser.java) 
  → AST (Expr.java, Module.java, Pattern.java)
  → Type Inference (TypeInference.java)
  → Bytecode Generation (Compiler.java)
  → JVM Class (.class)
```

### Key Components

- **Lexer.java**: Tokenization with position tracking (line:column)
- **Parser.java**: Recursive descent parser producing AST
- **TypeInference.java**: Hindley-Milner type inference with unification
- **Compiler.java**: ASM-based bytecode generation
- **Type.java**: Type system representation
- **Expr.java**: Expression AST nodes
- **Pattern.java**: Pattern matching AST nodes
- **Module.java**: Module-level declarations

### Type System

MiniML uses Hindley-Milner type inference:
- **Primitives**: `int`, `double`, `string`, `bool`, `unit`
- **Collections**: `list<'a>`
- **Algebraic**: `result<'a, 'e>` (OCaml-style error handling)
- **Functions**: `'a -> 'b`

Type variables are unified during inference. The compiler maintains a `typeMap` from expressions to inferred types.

### Runtime Classes

Located in `src/main/java/com/miniml/`:
- **Unit.java**: Singleton for unit value `()`
- **Result.java**: Sealed interface with `Ok<T,E>` and `Error<T,E>` records

## Common Tasks

### Adding a New Operator

1. Add token type to `Token.Type` enum
2. Add lexing logic in `Lexer.nextToken()`
3. Add to `Expr.Op` enum
4. Update parser precedence (add new method or extend existing)
5. Add type inference rule in `TypeInference.infer()`
6. Add bytecode generation in `Compiler.compileExpr()`

### Adding a New Expression Type

1. Add record to `Expr.java`
2. Add parsing in `Parser.java`
3. Add type inference in `TypeInference.java`
4. Add compilation in `Compiler.java`
5. Add tests in `tests/`

### Pattern Matching

Pattern matching compiles to:
1. Store scrutinee in local variable
2. For each case:
   - Save locals/localTypes state
   - Test pattern (instanceof checks, comparisons)
   - Jump to next case on failure
   - Bind variables, compile body
   - Jump to end
   - Restore locals/localTypes state
3. End label

**Important**: Pattern variables are stored as `Object` in `localTypes` when extracted from algebraic types (Result, etc.). They must be unboxed when used in operations.

## Known Limitations

1. **Function definitions**: Only `fn name params = body in expr` syntax supported. Top-level `let name params = body` is not supported (requires `fn`).
2. **Type annotations**: Not yet supported in surface syntax.
3. **Polymorphism**: Limited support for polymorphic recursion.
4. **Pattern matching**: Nested patterns not fully supported for Result types.

## Error Reporting

Error messages follow the format: `filename:line:column: message`

Example: `tests/bool_and.ml:2:6: Unexpected character '&'`

## Testing Strategy

- Test files in `tests/*.ml`
- Each test should be focused on a single feature
- Use `# Expected:` comments for non-boolean tests
- Boolean tests default to expecting `true`
- Run full test suite with `./run_tests.sh`

## Debugging Tips

### View Generated Bytecode
```bash
javap -c -p <ClassName>
```

### Enable ASM Verification
The compiler uses `ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS` for automatic stack frame computation.

### Common Issues

1. **VerifyError**: Usually stack frame inconsistency. Check that all match branches have consistent local variable states.
2. **Type mismatches**: Check `typeMap` has correct types. Pattern-bound variables from Result are stored as `Object`.
3. **Unboxing**: Variables stored as `Object` need explicit unboxing (CHECKCAST + intValue/doubleValue) before use in operations.

## Contributing

When making changes:
1. Update GRAMMAR.md if syntax changes
2. Add tests for new features
3. Ensure all tests pass: `./run_tests.sh`
4. Update this document if architecture changes
